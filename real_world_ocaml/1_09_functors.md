## 第九章 函子
到目前为止，我们已经看到OCaml的模块扮演了重要但受限的角色。实际上，我们已经知道它们可以作为一种机制，用以把代码组织到一些拥有自己接口的单元。但OCaml模块系统的作用远不止于此，它是构建通用代码和构造大型系统的强大工具。

笼统地说，函子是模块到模块的函数，它们可以用以解决大量的代码结构问题，包括：
- *依赖注入*  
  使系统的一些组件实现可替换。当你要为测试或模拟而制作系统中某部分的模型时，这一点特别有用。
- *自动扩展模块*  
  函子给了你一个用新功能扩展已有模块的标准方法。如，你可能想要基于一个基本比较函数来添加大量的比较运算符。手动做的话需要在每个类型上有大量重复代码，但函子让你可以只写一次就能应用到许多不同类型上。
- *带状态实例化模块*  
  模块可以包含可变状态，就是说你可能偶尔需要同一个模块的多个实例，每一个实例都有其独立的可变状态。函子使你可以将这种模块的构造自动化。
  
这仅仅是函子用途的一部分。此处我们不会试图提供函子所有用途的示例。相反，本章会尝试提供示例来展示为了更好地使用函子你需要掌握的语言特性和设计模式。

### 一个小例子

### A Bigger Example:Computing with Intervals
#### Making the Functor Abstract
#### Sharing Constraints
#### Destructive Substitution
#### Using Multiple Interface

### Extending Modules
