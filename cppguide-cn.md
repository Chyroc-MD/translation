# Google C++ Style Guide 中文版
原始文档：<http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml>
基于版本：3.260 

## 背景
C++是Google许多开源项目所使用的主要编程语言。正如每个C++程序员所知，这门语言有许多强大的特性，但是随之而来的是其复杂性，这反过来又使代码更容易引入Bug，难以阅读和维护。

这份指南的目标是通过详细描述在写C++代码时什么可以做什么不可以做来管理这种复杂性。这些规则可以保持代码基本的可控性，同时又允许程序员高效地使用C++的语言特性。

风格，或可读性，即我们管理C++代码的约定。“风格”这个术语有点不恰当，因为这些约定所覆盖的范围远远不只源码文件的格式。

保持代码易于管理的方法之一是加强一致性。任何程序员都可以快速理解另一个程序员的代码，这一点非常重要。保持统一的风格并遵循约定，意味着更容易使用“模式匹配”来推断各种标识符的含义。创建通用性，必需的习惯用语和模式使得代码更容易理解。有时可能有充分的理由改变某些风格规则，但是尽管如此，我们还是遵守规则以保持一致性。

本指南声明的另一件事是C++的特性臃肿。C++是门庞大的语言，拥有很多高级特性。有时我们限制甚至禁止使用某些特性。我们这样做来保持代码的简洁，以避免这些特性可能引起的各种错误和问题。本指南列出了这些特性并解释了为什么它们被限制使用。

Google开发的开源工程均遵循本指南的要求。

注意本指南不是C++教程：我们假设读者都熟悉C++。

## 头文件

通常每个.cc文件都要有个对应的.h文件。也有一些常见的例外，如单元测试以及只包含main()函数的小.cc文件。

正确使用头文件可以使用你代码的可读性、大小和性能都有很大的改观。

下面的规则会引导你规避使用头文件的各种陷阱。

### \#define 保护
所有的头文件都应该使用#define保护起来以阻止多次包含。符号名规则应该是`<项目>_<路径>_<文件>_H_`。

为了保证唯一性，它们应该基于在工程源代码树中的全路径。如，工程foo中的文件foo/src/bar/baz.h应该有以下的保护：
```c
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
```

### 前置声明
> 之前的版本这一节叫“头文件依赖”，对前置声明的好处和使用讲得很多。这一版指南调整了规则：明确禁止前置声明函数，不再要求使用前置声明，不鼓励前置声明模板。基本上开发中不用刻意考虑前置声明了。

可以对普通的类使用前置声明来避免不必要的#include。

#### 定义：
“前置声明”是类、函数或模版的声明，但不带相关定义。通常可以使用客户代码中实际使用的符号前置声明来取代#include行。

#### 优点：
- 不必要的头文件包含会强制编译器打开更多文件并处理更多输入。
- 同时也使用你的代码因为头文件的改变而更经常地被重编译。

#### 缺点 :
- 由于像模板、类型定义(typedef)、默认参数以及using声明等特性，确定一个前置声明的正式形式可能比较困难。
- 可能难以确定在给定的代码片中使用前置声明还是完整包含头文件，特别是涉及降至类型转换时更是如此。极端情况下，使用前置声明代替#include会默默改变代码行为。
- 前置声明一个头文件中的多个符号比直接包含这个头文件更啰嗦。
- 函数或模板的前置声明阻止了头文件作者对API做一些兼容改变，如加宽参数类型，或给模板添加一个带默认值的参数。
- 前置声明std命名空间中的符号会引发未定义的行为
- 为了前置声明构造的代码（如使用指针成员代替对象成员）可能更慢更复杂。
- 前置声明的实际效率优势没有得到证明。

#### 结论
- 当使用一个头文件中的函数时，包含它。
- 当使用一个类模板时，优先包含其头文件。
- 当使用普通类时，可以用前置声明，但是要小心那此前向声明能导致低效或错误的情况;当不确定时，包含相应的头文件即可。
- 不是仅仅为了使用前置声明而使用指针代替数据成员。

对于那些提供了你所需要的声明或定义的文件，总是使用#include; 不要依赖头文件中通过非直接引用的头文件传递来的符号。一个例外是myfile.cc文件可以依赖它对应的头文件myfile.h中的#include和前置声明。

