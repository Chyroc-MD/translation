# Google C++ Style Guide 中文版
原始文档：<http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml>
基于版本：3.260 

## 背景
C++是Google许多开源项目所使用的主要编程语言。正如每个C++程序员所知，这门语言有许多强大的特性，但是随之而来的是其复杂性，这反过来又使代码更容易引入Bug，难以阅读和维护。

这份指南的目标是通过详细描述在写C++代码时什么可以做什么不可以做来管理这种复杂性。这些规则可以保持代码基本的可控性，同时又允许程序员高效地使用C++的语言特性。

风格，或可读性，即我们管理C++代码的约定。“风格”这个术语有点不恰当，因为这些约定所覆盖的范围远远不只源码文件的格式。

保持代码易于管理的方法之一是加强一致性。任何程序员都可以快速理解另一个程序员的代码，这一点非常重要。保持统一的风格并遵循约定，意味着更容易使用“模式匹配”来推断各种标识符的含义。创建通用性，必需的习惯用语和模式使得代码更容易理解。有时可能有充分的理由改变某些风格规则，但是尽管如此，我们还是遵守规则以保持一致性。

本指南声明的另一件事是C++的特性臃肿。C++是门庞大的语言，拥有很多高级特性。有时我们限制甚至禁止使用某些特性。我们这样做来保持代码的简洁，以避免这些特性可能引起的各种错误和问题。本指南列出了这些特性并解释了为什么它们被限制使用。

Google开发的开源工程均遵循本指南的要求。

注意本指南不是C++教程：我们假设读者都熟悉C++。

## 头文件

通常每个.cc文件都要有个对应的.h文件。也有一些常见的例外，如单元测试以及只包含main()函数的小.cc文件。

正确使用头文件可以使用你代码的可读性、大小和性能都有很大的改观。

下面的规则会引导你规避使用头文件的各种陷阱。

### <span id="define_guard">\#define 保护</span>
所有的头文件都应该使用#define保护起来以阻止多次包含。符号名规则应该是`<项目>_<路径>_<文件>_H_`。

为了保证唯一性，它们应该基于在工程源代码树中的全路径。如，工程foo中的文件foo/src/bar/baz.h应该有以下的保护：
```c
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
```

### 前置声明
> 之前的版本这一节叫“头文件依赖”，对前置声明的好处和使用讲得很多。这一版指南调整了规则：明确禁止前置声明函数，不再要求使用前置声明，不鼓励前置声明模板。基本上开发中不用刻意考虑前置声明了。

可以对普通的类使用前置声明来避免不必要的#include。

#### 定义：
“前置声明”是类、函数或模版的声明，但不带相关定义。通常可以使用客户代码中实际使用的符号前置声明来取代#include行。

#### 优点：
- 不必要的头文件包含会强制编译器打开更多文件并处理更多输入。
- 同时也使用你的代码因为头文件的改变而更经常地被重编译。

#### 缺点 :
- 由于像模板、类型定义(typedef)、默认参数以及using声明等特性，确定一个前置声明的正式形式可能比较困难。
- 可能难以确定在给定的代码片中使用前置声明还是完整包含头文件，特别是涉及降至类型转换时更是如此。极端情况下，使用前置声明代替#include会默默改变代码行为。
- 前置声明一个头文件中的多个符号比直接包含这个头文件更啰嗦。
- 函数或模板的前置声明阻止了头文件作者对API做一些兼容改变，如加宽参数类型，或给模板添加一个带默认值的参数。
- 前置声明std命名空间中的符号会引发未定义的行为
- 为了前置声明构造的代码（如使用指针成员代替对象成员）可能更慢更复杂。
- 前置声明的实际效率优势没有得到证明。

#### 结论
- 当使用一个头文件中的函数时，包含它。
- 当使用一个类模板时，优先包含其头文件。
- 当使用普通类时，可以用前置声明，但是要小心那此前向声明能导致低效或错误的情况;当不确定时，包含相应的头文件即可。
- 不是仅仅为了使用前置声明而使用指针代替数据成员。

对于那些提供了你所需要的声明或定义的文件，总是使用#include; 不要依赖头文件中通过非直接引用的头文件传递来的符号。一个例外是myfile.cc文件可以依赖它对应的头文件myfile.h中的#include和前置声明。

### 内联函数
只内联小于10行代码的小函数。

#### 定义：
你可以以一种方式来声明函数，以允许编译器将它们就地展开，而不是通过普通函数调用机制来调用。
#### 优点：
只要函数足够小，将其内联可以产生更高效的目标代码。对于存取函数和一些性能关键的小函数，可以放心使用内联。
#### 缺点：
过度使用内联会导致程序变慢。内联可能使代码变大或变小，这取决于函数大小。内联一个很小的存取函数通常会减小代码大小，但是内联一个很大的函数则可能使代码体积暴增。利用指令缓存，在现代处理器上小代码通常跑得更快。
#### 结论：
一个合理的经验准则是：不要内联超过10行的函数。要警惕析构函数，由于隐含成员和基类析构函数的调用，它们往往比表面上看起来要长。

另一个有用的经验法则：内联那些含有循环或switch语句的函数通常是不划算的（除非，这循环或switch语句通常都不会执行到）。

还有一点很重要，即使函数被声明为内联的，它们也不一定总是会被内联；比如，虚函数和递归函数就不能正常内联。通常递归函数不应该被内联。内联一个虚函数的主要原因是要将其定义放在类中，这是为了方便或是文档化其自身的行为，比如存取函数。

### -inl.h文件
当需要时，你可以使用后缀名为-inl.h的文件来定义复杂的内联函数。

内联函数的定义要放在一个头文件中，这样编译器才能函数在调用处知道其定义。然而，实现代码应该是属于.cc文件的，除非有明显的可读性和性能优势，否则我们并不想在.h文件放太多的实现代码。

如果一个内联函数很短，里面只有很少的一点逻辑，你应该把代码放在.h文件中。比如存取函数就应该放在类定义中。出于对实现者和调用者的方便，更复杂的内联函数也可以放在.h文件中，如果这使得.h文件变得过于笨重，你也可以把其代码放到一个单独的-inl.h文件中。把实现和类定义分开，当需要时仍经允许包含实现头文件。

-inl.h文件的另一个用处是定义函数模板。这可以使你的模板定义更易阅读。

不要忘记-inl.h文件也其它的头文件一样需要[#define保护](#define_guard).

### 函数参数顺序
当定义一个函数时，参数顺序为：输入，然后是输出。

C/C++函数的参数或是输入或是输出或两者皆是。输入参数通常是值或常量引用，而输出或输入/输出参数是非常量指针。当安排参数顺序时，把所有的输入参数放到输出参数前面。尤其不要因为一个参数是新添加的就把它放在最后面；新的输入参数也要放在输出参数前面。

这不是硬性规定。既是输入又是输出的参数（通常是类或结构体）把事情变得复杂，同时，为了和相关函数保持我们一惯主张的一致性，你有时可以有所变通。

### 名称以及包含顺序
使用标准的头文件包含顺序增强可读性，并避免隐藏依赖：C库，C++库，其它库头文件，本项目库头文件。

所有本工程的头文件应该按源代码目录树结构排列，避免使用UNIX的特殊缩写 .（当前目录）或 ..（父目录）。比如，google-awesome-project/src/base/logging.h应该这样被包含：
```c
#include "base/logging.h"
```
在dir/foo.cc或dir/foo_test.cc中，其主要目的是实现或测试dir2/foo2.h中的声明的东西, 你的包含次序应该是这样的：
1. dir2/foo2.h (优先位置 — 后面会详述).
2. C系统文件。
3. C++系统文件。
4. 其它库的.h文件。
5. 本工程内的.h文件。

按这种顺序，如果dir/foo2.h遗漏了必要的头文件，dir/foo.cc或dir/foo_test.cc的编译就会失败。这样，这条规则就保证了编译首先在使用这些文件的人面前失败，而不是使用其它包的无辜的人。

dir/foo.cc和dir2/foo2.h通常在同一目录中（比如base/basictypes_test.cc和base/basictypes.h），但也可以在不同的目录中。

在上面的每一块中，按字母顺序排列是个好主意。注意旧代码可以不符合这条规则，但应该在方便的时候修改它。

比如，google-awesome-project/src/foo/internal/fooserver.cc中的包含次序应看起来像这样：
```c
#include "foo/public/fooserver.h"  // Preferred location.

#include <sys/types.h>
#include <unistd.h>
#include <hash_map>
#include <vector>

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/public/bar.h"
```

