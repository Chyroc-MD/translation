Google C++ Style Guide 中文版
原始文档：<http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml>
基于版本：3.260 

# 背景
C++是Google许多开源项目所使用的主要编程语言。正如每个C++程序员所知，这门语言有许多强大的特性，但是随之而来的是其复杂性，这反过来又使代码更容易引入Bug，难以阅读和维护。

这份指南的目标是通过详细描述在写C++代码时什么可以做什么不可以做来管理这种复杂性。这些规则可以保持代码基本的可控性，同时又允许程序员高效地使用C++的语言特性。

风格，或可读性，即我们管理C++代码的约定。“风格”这个术语有点不恰当，因为这些约定所覆盖的范围远远不只源码文件的格式。

保持代码易于管理的方法之一是加强一致性。任何程序员都可以快速理解另一个程序员的代码，这一点非常重要。保持统一的风格并遵循约定，意味着更容易使用“模式匹配”来推断各种标识符的含义。创建通用性，必需的习惯用语和模式使得代码更容易理解。有时可能有充分的理由改变某些风格规则，但是尽管如此，我们还是遵守规则以保持一致性。

本指南声明的另一件事是C++的特性臃肿。C++是门庞大的语言，拥有很多高级特性。有时我们限制甚至禁止使用某些特性。我们这样做来保持代码的简洁，以避免这些特性可能引起的各种错误和问题。本指南列出了这些特性并解释了为什么它们被限制使用。

Google开发的开源工程均遵循本指南的要求。

注意本指南不是C++教程：我们假设读者都熟悉C++。

# 头文件

通常每个.cc文件都要有个对应的.h文件。也有一些常见的例外，如单元测试以及只包含main()函数的小.cc文件。

正确使用头文件可以使用你代码的可读性、大小和性能都有很大的改观。

下面的规则会引导你规避使用头文件的各种陷阱。

## <span id="define_guard">\#define 保护</span>
所有的头文件都应该使用#define保护起来以阻止多次包含。符号名规则应该是`<项目>_<路径>_<文件>_H_`。

为了保证唯一性，它们应该基于在工程源代码树中的全路径。如，工程foo中的文件foo/src/bar/baz.h应该有以下的保护：
```c
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
```

## 前置声明
> 之前的版本这一节叫“头文件依赖”，对前置声明的好处和使用讲得很多。这一版指南调整了规则：明确禁止前置声明函数，不再要求使用前置声明，不鼓励前置声明模板。基本上开发中不用刻意考虑前置声明了。

可以对普通的类使用前置声明来避免不必要的#include。

### 定义：
“前置声明”是类、函数或模版的声明，但不带相关定义。通常可以使用客户代码中实际使用的符号前置声明来取代#include行。

### 优点：
- 不必要的头文件包含会强制编译器打开更多文件并处理更多输入。
- 同时也使用你的代码因为头文件的改变而更经常地被重编译。

### 缺点 :
- 由于像模板、类型定义(typedef)、默认参数以及using声明等特性，确定一个前置声明的正式形式可能比较困难。
- 可能难以确定在给定的代码片中使用前置声明还是完整包含头文件，特别是涉及降至类型转换时更是如此。极端情况下，使用前置声明代替#include会默默改变代码行为。
- 前置声明一个头文件中的多个符号比直接包含这个头文件更啰嗦。
- 函数或模板的前置声明阻止了头文件作者对API做一些兼容改变，如加宽参数类型，或给模板添加一个带默认值的参数。
- 前置声明std命名空间中的符号会引发未定义的行为
- 为了前置声明构造的代码（如使用指针成员代替对象成员）可能更慢更复杂。
- 前置声明的实际效率优势没有得到证明。

### 结论
- 当使用一个头文件中的函数时，包含它。
- 当使用一个类模板时，优先包含其头文件。
- 当使用普通类时，可以用前置声明，但是要小心那此前向声明能导致低效或错误的情况;当不确定时，包含相应的头文件即可。
- 不是仅仅为了使用前置声明而使用指针代替数据成员。

对于那些提供了你所需要的声明或定义的文件，总是使用#include; 不要依赖头文件中通过非直接引用的头文件传递来的符号。一个例外是myfile.cc文件可以依赖它对应的头文件myfile.h中的#include和前置声明。

## 内联函数
只内联小于10行代码的小函数。

### 定义：
你可以以一种方式来声明函数，以允许编译器将它们就地展开，而不是通过普通函数调用机制来调用。
### 优点：
只要函数足够小，将其内联可以产生更高效的目标代码。对于存取函数和一些性能关键的小函数，可以放心使用内联。
### 缺点：
过度使用内联会导致程序变慢。内联可能使代码变大或变小，这取决于函数大小。内联一个很小的存取函数通常会减小代码大小，但是内联一个很大的函数则可能使代码体积暴增。利用指令缓存，在现代处理器上小代码通常跑得更快。
### 结论：
一个合理的经验准则是：不要内联超过10行的函数。要警惕析构函数，由于隐含成员和基类析构函数的调用，它们往往比表面上看起来要长。

另一个有用的经验法则：内联那些含有循环或switch语句的函数通常是不划算的（除非，这循环或switch语句通常都不会执行到）。

还有一点很重要，即使函数被声明为内联的，它们也不一定总是会被内联；比如，虚函数和递归函数就不能正常内联。通常递归函数不应该被内联。内联一个虚函数的主要原因是要将其定义放在类中，这是为了方便或是文档化其自身的行为，比如存取函数。

## -inl.h文件
当需要时，你可以使用后缀名为-inl.h的文件来定义复杂的内联函数。

内联函数的定义要放在一个头文件中，这样编译器才能函数在调用处知道其定义。然而，实现代码应该是属于.cc文件的，除非有明显的可读性和性能优势，否则我们并不想在.h文件放太多的实现代码。

如果一个内联函数很短，里面只有很少的一点逻辑，你应该把代码放在.h文件中。比如存取函数就应该放在类定义中。出于对实现者和调用者的方便，更复杂的内联函数也可以放在.h文件中，如果这使得.h文件变得过于笨重，你也可以把其代码放到一个单独的-inl.h文件中。把实现和类定义分开，当需要时仍经允许包含实现头文件。

-inl.h文件的另一个用处是定义函数模板。这可以使你的模板定义更易阅读。

不要忘记-inl.h文件也其它的头文件一样需要[#define保护](#define-保护).

## 函数参数顺序
当定义一个函数时，参数顺序为：输入，然后是输出。

C/C++函数的参数或是输入或是输出或两者皆是。输入参数通常是值或常量引用，而输出或输入/输出参数是非常量指针。当安排参数顺序时，把所有的输入参数放到输出参数前面。尤其不要因为一个参数是新添加的就把它放在最后面；新的输入参数也要放在输出参数前面。

这不是硬性规定。既是输入又是输出的参数（通常是类或结构体）把事情变得复杂，同时，为了和相关函数保持我们一惯主张的一致性，你有时可以有所变通。

## 名称以及包含顺序
使用标准的头文件包含顺序增强可读性，并避免隐藏依赖：C库，C++库，其它库头文件，本项目库头文件。

所有本工程的头文件应该按源代码目录树结构排列，避免使用UNIX的特殊缩写 .（当前目录）或 ..（父目录）。比如，google-awesome-project/src/base/logging.h应该这样被包含：
```c
#include "base/logging.h"
```
在dir/foo.cc或dir/foo_test.cc中，其主要目的是实现或测试dir2/foo2.h中的声明的东西, 你的包含次序应该是这样的：

1. dir2/foo2.h (优先位置 — 后面会详述).
2. C系统文件。
3. C++系统文件。
4. 其它库的.h文件。
5. 本工程内的.h文件。

按这种顺序，如果dir/foo2.h遗漏了必要的头文件，dir/foo.cc或dir/foo_test.cc的编译就会失败。这样，这条规则就保证了编译首先在使用这些文件的人面前失败，而不是使用其它包的无辜的人。

dir/foo.cc和dir2/foo2.h通常在同一目录中（比如base/basictypes_test.cc和base/basictypes.h），但也可以在不同的目录中。

在上面的每一块中，按字母顺序排列是个好主意。注意旧代码可以不符合这条规则，但应该在方便的时候修改它。

比如，google-awesome-project/src/foo/internal/fooserver.cc中的包含次序应看起来像这样：
```c
#include "foo/public/fooserver.h"  // Preferred location.

#include <sys/types.h>
#include <unistd.h>
#include <hash_map>
#include <vector>

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/public/bar.h"
```

# 作用域

## 命名空间
.cc文件中鼓励使用匿名命名空间。使用具名命名空间时，选择基于工程的名字，尽可能使用其路径。不要使用using指令（ _应该是指不能使用using namespace吧？_ ）。

### 定义：
命名空间把全局作用域划分为独立的具名作用域，以此可以有效防止全局作用域中的命名冲突。

### 优点：
命名空间在类（可嵌套的）外又提供了一层命名轴线（也是可嵌套的）。

比如，如果两个工程的全局作用域中都有一个名为Foo的类，这在编译或进行时就会造成冲突。如果每个工程都把它们的代码放在一个命名空间中，这样project1::Foo和project2:Foo就是两个不同的符号，自然没有冲突。

### 缺点：
正是由于和类一样提供了额外的（都是可嵌套的）名字轴线，命名空间具有一些迷惑性。

在头文件中使用匿名空间很容易违背C++的唯一定义原则（ODR，One Definition Rule）。

### 结论：
要根据以下策略使用命名空间。要像示例中那样在命名空间结束处使用注释。

#### 匿名空间
- 匿名空间在.cc中是允许的，甚至是被鼓励的，以此可以避免命名冲突：

```C++
namespace {                           // 这个一个.cc文件中的代码

// 命令空间的内容不缩进
enum { kUnused, kEOF, kError };        // Commonly used tokens.
bool AtEof() { return pos_ == kEOF; }  // Uses our namespace's EOF.

}  // namespace
```
尽管如此，特定类相关的文件作用域声明，可以在类中被声明为类型、静态成员或静态成员函数，而不是某个匿名空间的成员。

- 不要在.h文件中使用匿名空间。

#### 具名空间
具名空间应该像下面这样使用：
- 使用命名空间把除头文件包含，gflags定义/声明以及类的前置声明以外的整个代码包装起来，以别于其它命令空间：

```C++
// In the .h file
namespace mynamespace {

// 所有声明都置于命名空间中。
// 注意没有缩进
class MyClass {
 public:
  ...
  void Foo();
};

}  // namespace mynamespace

// In the .cc file
namespace mynamespace {

// 函数定义在命名空间作用域中
void MyClass::Foo() {
  ...
}

}  // namespace mynamespace
```
通常.cc文件会有更多复杂细节，包括引用其它命名空间中的类。
```C++
#include "a.h"

DEFINE_bool(someflag, false, "dummy flag");

class C;  // 全局命名空间中类C的前置声明
namespace a { class A; }  // a::A 的前置声明

namespace b {

...code for b...         // Code goes against the left margin.

}  // namespace b
```
- 不要在std空间中声明任何东西，甚至不要前置声明标准库的类。在std空间中声明东西会产生不确定的行为，比如不可移植。要声明标准库中的东西，包含相应的头文件就好了。
- 不要使用using指令来引入一个命名空间中的所有名字。

```C++
// 禁止！！！ -- 这会污染命令空间
using namespace foo;
```
- 在.cc文件中的任何地方，.h文件中的函数、方法以及类中都可以使用using声明

```C++
// 在.cc文件这是允许的
// .h文件中，必须是在函数、方法或类内部
using ::foo::bar;
```
-  在.cc文件任何地方，在包装整个.h文件的命名空间内的任何地方，以及在函数和方法中，都允许使用命名空间别名。

```C++
// .cc文件中为常用的起短名
namespace fbz = ::foo::bar::baz;

// .h文件中为常用的起短名
namespace librarian {
// 下面这些别名在所有包含此头文件的文件中均可见（当然是在librarian空间中）:
// 所以一个工程中别名的选择应该保持一致
namespace pd_s = ::pipeline_diagnostics::sidetable;

inline void my_inline_function() {
  // 只在一个函数或方法作用域中的命名空间别名.
  namespace fbz = ::foo::bar::baz;
  ...
}
}  // namespace librarian
```
注意，头文件中的别名在任何包含它的文件中均可见，所以公共头文件（那些要在工程外使用的）和它们传递包含的头文件中都要避免使用别名，这是保证公共API尽可能小的举措之一。

## 嵌套类
当嵌套类是接口的一部分时，尽管你可以使用，但还是应该考虑使用[命名空间](#命名空间)来将其声明从全局作用域中分开。

### 定义：
一个类中可以定义另一类; 这个嵌套类也被称为成员类。
```C++
class Foo {

 private:
  // Bar is a member class, nested within Foo.
  class Bar {
    ...
  };

};
```
### 优点：
当嵌套类（或成员类）只被外围类中使用时是非常有用的; 把它作为成员类放到外围类的作用域中，而不用类名去污染外层作用域。嵌套类可以在外围类中前置声明，然后在.cc文件中定义，这样可以避免在外围类的声明中定义嵌套类，因为嵌套类的定义往往只与实现有关。

### 缺点：
嵌套类只有在外围类的定义内部才能前置声明。因此，任何使用了Foo::Bar*指针的头文件都要包含Foo类完整的声明。

### 结论：
除非嵌套类是接口的一部分，如持有一些方法的选项，否则不要将其定义为公有的。

## 非成员函数，静态成员函数，和全局函数
尽量使用命名空间中的非成员函数或静态成员，而少用全局函数。

### 优点：
非成员函数和静态成员在某些情况下会非常有用。将非成员函数放在一个命名空间中以避免污染全局命名空间。

### 缺点：
非成员函数和静态成员通常更应该成为一个新类的成员， 特别是当它们访问外部资源或有显著的依赖关系是，更应如此。

### 结论：
有时候定义一个与类实例无关的函数很有用，甚至是必要的。这样的函数可以是一个静态成员或非成员函数。非成员函数不应该依赖外部变量，并且总是尽量放在一个命名空间中。相比单纯创建一个类来组织静态成员函数而不共享任何数据，使用[命名空间](#命名空间)更合适。

定义在同一编译单元里的函数在被从其它编译单元直接调用时，会引入不必要的耦合和运行时依赖，静态成员函数尤是如此。考虑将这些函数提取到一个新类，或放置于一个独立库的命名空间中。

如果你要必须定义一个非成员函数并且它只在其所在的.cc文件中使用，使用匿名[命名空间](#命名空间)或static关键字（如 ```static int Foo(){...}```）来限制其作用域。

## 局部变量
尽量将函数变量放在一个较小的作用域内，并在声明时进行初始化。

C++允许你在函数的任何位置声明变量。我们鼓励你在尽可能小的作用域内声明，离第一次使用越进越好。这使得读者更容易看到变量的声明、定义以及初始值。特别提醒，应该初始化而非声明再赋值，如：
```C++
int i;
i = f(); // 不好 -- 初始化和声明分开。
```
```C++
int j = g(); // 好 -- 声明时初始化。
```
```C++
vector<int> v;
v.push_back(1);  // 应优先使用括号初始化。
v.push_back(2);
```
```C++
vector<int> v = {1, 2};  // 好 -- 变量 v 声明时初始化。
```
注意gcc正确实现了```for (int i = 0; i < 10; ++i)```(i的作用域仅为此for循环)，所以在同一作用域的其它for循环中可以重复使用i。将声明作用域限定于在while和if语句中也是正确的，如：
```C++
while (const char* p = strchr(str, '/')) str = p + 1;
```

有一点需要注意：如果变量是一个对象，它的构造函数会在每一次进入作用域创建对象时被调用，它的析构函数也会在每次离开作用域时被调用。
```C++
// 无效率的实现：
for (int i = 0; i < 1000000; ++i) {
  Foo f;  // Foo的构造函数和析构函数分别被调用了1000000次。
  f.DoSomething(i);
}
```

这时在循环之外定义循环中使用的变量要高效的多：
```C++
Foo f;  // Foo的构造函数和析构函数只分别被调用了1次。
for (int i = 0; i < 1000000; ++i) {
  f.DoSomething(i);
}
```

## 静态和全局变量
禁止使用类静态和全局变量：由于构造和析构顺序的不确定定，它们会引入难以查找的BUG。

有静态存储周期的变量，包括全局变量，静态变量，静态类成员变量以及函数的静态变量，必须是原生数据类型（POD：Plain Old Data）：只能是整数类型，字符型，浮点型，或指针，或POD类型数据的数组或结构体。

静态变量的初始化顺序在C++中只有部分定义，甚至在每次构建时还会变化，这会引起难以查找的BUG。因此在禁止类全局变量的同时，我们也不允许用一个函数的返回值初始化一个静态的POD变量，除非这个函数（如getenv()，或getpid()）本身不依赖于任何其它全局变量。

同样，析构函数的调用顺序被定义为和构造函数调用顺序相反。由于构造顺序不确定，析构顺序自然也是如此。例如，程序结束时一个静态变量可能已经被销毁了，便是程序还在跑 -- 可能在另一个线程中 -- 这时试图访问此变量就会失败。又或是一个静态'string'变量的析构函数可以会比另一个持有此变量引用的类先析构。

综上所述，我们只允许POD类型的静态变量。这条规则完全禁止了```vector```（可以使用C数组代替）或```string```（可以使用```const char []```代替）。

如果你需要一个class类型的静态或全局变量，可以在```main()```函数或```pthread_once()```函数中考虑初始化一个指针（永不释放）。注意此处的指针必须是原生指针，而不能是智能指针，因为智能指针的析构函数也有顺序问题，这正是我们极力避免的。

# 类
类是C++代码的基本单元，我们自然会广泛使用。这一节列出了我们在写一个类时应该遵循的主要规则。

## 在构造函数中做事
在构造函数中要避免执行复杂的初始化（尤其是那些可能失败或需要调用虚方法的初始化）。

### 定义：
在构造函数中可以进行初始化操作。

### 优点：
打字方便。不需要纠结类是否已经初始化。

### 缺点：
在构造函数中进行实质操作的问题在于：
- 构造函数无法报告错误，且不能使用异常。
- 一旦失败，我们就持有了一个初始化不完全的对象，这可能是一个不确定的状态。
- 如果调用了虚函数，这些调用不会被分派给子类的实现。即使你的类现在没有子类，未来的改动也可能会默默引入这个问题，这会引起很大的混乱。
- 如果有人创建了这个类型一个全局变量（这违背了上面的规则，但总有人会这么做），构造函数会在```main()```函数之前调用，这时的一些隐含的假设可能并不成立。如，gflags此时尚未初始化。

### 结论：
构造函数永远不要调用虚函数，也不要抛出非致命的错误。如果你的对象需要实质初始化，可以考虑使用一个工厂函数或```Init()```方法。

## 默认构造函数
如果一个类中定义了成员变量又没有其它的构造函数，就必须定义一个默认构造函数。否则编译器就会替你定义一个，这通常都不是什么好事。

### 定义：
当我们不带参数```new```一个类对象，会调用默认构造函数。当调用```new[]```创建数组时，默认构造函数也总会被调用。

### 优点：
将结构体默认初始化成“不可能的”值，使调试更容易。

### 缺点：
对代码编写者来说，增加了额外的工作量。

### 结论：
如果一个类中定义了成员变量又没有其它的构造函数，就必须定义一个默认构造函数（没有参数的构造函数）。将类以一种内部状态一致且有效的方式初始化无疑是更可取的。

这么做的原因是，如果没有其它构造函数又没有定义默认构造函数，编译器就会帮你生成一个，而编译生成的这个构造函数未必能合理初始化你的对象。

如果你的类继承自其它类，你又没有添加新的成员变量，那就不必非要有一个默认构造函数。

## 显式构造函数
对只有一个参数的构造函数使用C++的```explicit```关键字。

### 定义：
通常一个只有一个参数的构造函数，可以被用作隐式转换。例如，你定义了```Foo::Foo(string name)```，然后传递一个string给一个以```Foo```为参数的函数，此时这个构造函数会被调用，把```string```转换为```Foo```，然后将它传递给函数。这可能带来方便，但是当转换以及新对象的创建不是你预期的时候，这就成了麻烦之源。用```explicit```来声明一个构造函数，可以阻止它被隐式调用而形成的转换。

### 优点：
避免不合适的转换。

### 缺点：
没有。

### 结论：
我们要求所有单参数的构造函数都是显式的。在类的单参数构造定义前都加上```explicit```：```explicit Foo(string name);```。

拷贝构造函数是一个例外，在为数不多的被允许使用的情况下，它都不应是显式的。作为其它类的透明包装器的类也是个例外。这些例外都应该用注释清楚标注出来。

最后，只接收一个初始化列表的构造函数应该是非显式的。这是为了允许用大括号初始化列表赋值的方式构造类（如 ```MyType m = {1, 2}```）。
> initializer_list是C++0x引入的特性

## 拷贝构造函数
只在必要的时候才提供拷贝构造函数和赋值操作符。否则，应使用 DISALLOW_COPY_AND_ASSIGN宏来禁止它们。

### 定义：
拷贝构造函数和赋值操作符用来构造一个对象的拷贝。在某些情况下编译器会隐式调用拷贝构造函数，如，在按值传递对象时。

### 优点：
拷贝构造函数使拷贝对象变得简单。STL容器要求所有的内容都要是可拷贝且可赋值的。拷贝构造函数比```CopyFrom()```式的方法更高效，因为把构造和拷贝结合在一起，编译器在某些情况下可以省略它们，并且更容易避免堆内存分配。

### 缺点：
隐式对象拷贝是C++中许多bug和性能问题的根源。同时也降低了可读性，因为相比引用传递，跟踪值传递的对象变得困难，也难以确定哪些改变会反映出去。

### 结论：
只有少数的类需要可拷贝。大多数类都不应该有拷贝构造函数和赋值操作符。大多数情况下，一个指针或引用可以代替值拷贝，性能还更好。如，你可以传递给函数一个引用或指针而非一个值，也可以在STL容器中保存指针而非对象。

如果你的类需要可拷贝，优先使用一个拷贝方法，如```Copyfrom()```或```Clone()```，而不是使用拷贝构造函数，因为这些方法不会被隐式调用。如果拷贝函数不满足你的要求（如性能原因，或你的类需要在STL容器中存值），那就 **同时** 提供拷贝构造函数和赋值操作符。

如果你的类不需要拷贝构造函数和赋值操作符，就必须显式禁止它们。可以在class的private区为构造函数和赋值操作符添加假的声明，但不提供相关定义（这样所有使用它们的企图都会引发一个链接错误）。

方便起见，一个DISALLOW_COPY_AND_ASSIGN宏可以这样使用:
```C++
// 一个禁止拷贝构造函数和赋值操作符的宏
// 它应该被用在类的private声明区
#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
  TypeName(const TypeName&);               \
  void operator=(const TypeName&)
```
然后，在类Foo中：
```C++
class Foo {
 public:
  Foo(int f);
  ~Foo();

 private:
  DISALLOW_COPY_AND_ASSIGN(Foo);
};
```
## 结构体 VS 类
只持有数据的被动对象才能作为结构体;其它的都应该用类。

C++中struct关键字和class关键字的行为几乎一样。我们给每个关键字添加了自己的语义，所以你应该为你定义的数据类型使用合适的关键字。

结构体只能用在只持有数据的被动对象上，并且可以有相关的常量，但是除了存取数据成员外没有任何其它功能。对数据成员的存取都是通过直接访问而不是调用方法。结构体的方法都不是私有的，但是仅限于操作数据成员，如，构造函数，析构函数，```Initialize()```，```Reset()```，```Validate()```。

如果需要更多功能，类更合适。如果不确定，就用类。

为了与STL保持一致，对于functors和traits你可以使用结构体代替类。

注意结构体和类的成员变量有不同的[命名规则](#变量命名)。

## 继承
组合通常都比继承更合适。当使用继承时，只能用公有继承。

### 定义：
当一个子类继承一个基类时，他就包含了父类中定义的所有数据和操作。实践中，继承在C++中有两种主要用法：实现继承，实际代码都被子类继承; 还有接口继承，只有方法名被继承。

### 优点：
通过原样复用基类代码，实现继承减少了代码量。由于继承是编译期声明的，程序员和编译器都可以理解操作并检查错误。接口继承可用以强制暴露特定的API。在这种情况下，当一个类没有定义必要的API方法时，编译器也可以检查到。

### 缺点：
对于实现继承，实现子类的代码在基类和子类间传播，这使得理解一个实现更为困难。子类不能重写非虚函数，所以子类也不能改变其实现。基类可能也定义了一些数据成员，所以还需要指明基类的物理布局。

### 结论：
所有的继承都应该是公有的。如果你想要一个私有继承，那么你应该把基类的实例作为成员包含进来。

不要过度使用实现继承。使用组合往往更合适。试着把继承的使用限制在“is-a”的情况：只有```Bar```确实是一种```Foo```时，```Bar```才能作为```Foo```的子类。

尽可能使用虚析构函数。如果类中有虚方法，那么析构函数就一定要是虚方法。

仅对于那些可能在子类中访问的成员函数才使用protected。注意数据成员都应该是私有的。

重定义一个继承的虚函数，要在声明中显式使用virtual关键字。原因是：如果省略virtaul，为了搞清楚一个函数是不是虚函数，读者就需要检查所有的父类。

## 多重继承
多重继承只有极少的情况下有用。只有在最多一个基类有实现，其它的基类都是被标以Interface后缀的[纯接口](#接口)时，我们才允许使用多重继承。

### 定义：
多重继承允许一个子类可以有多个基类。我们需要把纯接口的基类和有实现的基类加以区别。

### 优点：
多重继承可能让你比单继承（见[继承](#继承)）复用更多的代码。

### 缺点：
多重继承真正有用的情况极少。当多重继承看似适用时，你往往可以发现另一种更明确，更干净的解决方案。

### 结论：
多重继承只有在除第一个基类外都是[纯接口](#接口)时才允许使用。为了确保它们是纯接口，必须以Interface为后缀。

**注意：**该规则在Windows下有个[特例](#windows代码)。

## 接口
满足下面条件的类允许使用Interface作为后缀，但不是强制的。

### 定义：
满足下面要求的类被称为纯接口：
- 只有公共的纯虚方法("= 0")以及静态方法（需要下文提到的析构函数）。
- 没有非静态数据成员。
- 不需要定义任何构造函数。如果提供了构造函数，那么一定是无参并且protected的。
- 如果是一个子类，只能从满足这些条件的被标以Interface后缀的类继承。

由于声明了纯虚方法，接口类不能被直接实例化。为了确保接口的所有实现都能正确销毁，接口类必须提供一个虚析构函数（必须不是纯虚的，尽管这违反了第一个条件）。关于这一点，在Stroustrup的《The C++ Programming Language, 3rd Edition》中的第12.4节有详细描述。

### 优点：
一个类被标以Interface后缀可以提醒其它人一定不能给它添加实现的方法或非静态数据成员。这个在[多重继承](#多重继承)中尤为重要。另外，对于Java程序员，接口的概念已经深入人心。

### 缺点：
Interface后缀使类名变长，可能会给阅读和理解带来不便。同时，接口属性作为一种实现细节不应暴露给使用者。

### 结论：
只有当一个类满足上述条件时才可以使用Interface后缀。反过来我们不做要求：满足上述条件的类不强制以Interface为后缀。

## 运算符重载
除了极少数特殊情况，不要重载运算符。

### 定义：
一个类可以定义作用于此类的`+`和`/`等运算符，使其可以像内建运算符一样使用。

### 优点：
一个类和内建类型（如`int`）行为一致，这使代码看上去更直观。重载的运算符比形如`Equals()`和`Add()`的函数名更出彩。为了使有些模板函数正确工作，你可能需要定义操作符。

### 缺点：
尽管重载运算符使代码更直观，它却有几个缺点：
- 会混淆视听，让我们误以为一些耗时的操作和内建操作一样轻巧。
- 查找重载运算符的调用点变得困难得多。查找`Equals()`要比查找相关的`==`调用容易得多。
- 有些运算符也操作指针，重载它们很容易引入bug。`Foo + 4`做一件事，`&Foo + 4`可能与之完全不同。编译器对这两种情况都不会提示，这使得调试异常困难。

重载还有想像不到的副作用。如，一个类重载了一元操作符`operator&`，那么它就不能安全的前置声明了。

### 结论：
通常都不要重载运算符。特别是赋值运算符(`operator=`)更容易出错，更应该避免重载。如果需要你可以定义`Equals()`和`CopyFrom()`函数。同时，如果一个类有一丁点可能被前置声明，那么在任何情况下都要避免重载危险的一元操作符`operator&`。

然而，还是有极少的情况你需要重载一个运算符以便与模板或“标准”C++类（如用以打印日志的`operator<<(ostream&, const T&)`）交互。只有有充分正当的理由才能重载，但你还是要尽量避免这种情况。特别不要为了使你的类可以作为STL容器的键值而重载`operator==`和`operator<`，这时，你应该在声明容器时创建判断相等和比较大小的仿函数类型。

一些STL算法要求你重载`operator==`，这时你可以这样做，但是要在文档中说明原因。

参考[拷贝构造函数](#拷贝构造函数)和[函数重载](#函数重载)。

## 存取控制
数据成员都定义成私有的，如果需要就提供存取函数来访问（因为技术原因，当使用Google Test时，允许夹具类的数据成员是`pretected`的）。通常一个名为`foo_`的成员，存取函数名为`foo()`，可能还要一个设值函数`set_foo()`。例外：静态常量数据成员不需要(通常称为`kFoo`)是私有的。

存取函数在头文件中内联定义。

参见[继承](#继承)和[函数命名](#函数命名)。

## 声明顺序
在类中使用特定的声明顺序：`public:`在`private:`前，方法在数据成员（变量）前，等。

你的类应该以`public:`区开始，然后是`protected:`区，然后是`private:`区。如果某区是空的，就忽略它。

每一区中，声明通常应该按如下的顺序：
- 类型定义（`typedef`）和枚举
- 常量（静态常量成员）
- 构造函数
- 析构函数
- 方法，包括静态方法
- 数据成员（除子静态常量成员）

友元声明应该总是在`private`区，`DISALLOW_COPY_AND_ASSIGN`宏应该在`private:`区最后，它应该是一个类的末尾。参见[拷贝构造函数](#拷贝构造函数)。

相应的.cc文件中方法定义顺序应该尽量和头文件中的保持一致。

大的方法定义不要内联在类定义中。通常，那些没有特别意义或对性能要求高，还非常短小的方法才可以内联。参见[内联函数](#内联函数)。

## 写短小函数
尽量编写短小精炼的函数。

我们意识到有时候长函数更合适，所以在函数长短方面没有硬性的规定。如果一个函数超过40行，就考虑一下在不破坏程序结构的情况下能否将其拆分。

即使你的长函数现在可以完美工作，几个月后可能会有人为其添加新的行为，这可能引入难以查找的bug。保持函数短小、简单可以使他人更容易阅读和修改你的代码。

你也许会在一些代码中发现一些又长又复杂的函数。不要被修改已有代码吓倒：如果和复杂的函数打交道，你发现错误难以调试，或是你只想使用一部分代码，你可以考虑把这个函数拆成可控的小函数。

# Google的奇技淫巧
我们使用了大量技巧和工具使C++代码更健壮，我们使用C++的方式可能与你在别处见到的有所不同。

## 智能指针
当你确实需要指针时，`unique_ptr`最好了，但为了支持老版本的C++，用`scoped_ptr`也尚可。只有在确实需要共享一个对象的所有权时（如在一个STL容器中），你才能使用`shared_ptr`来管理非常量。永不要使用`auto_ptr`。

### 定义：
智能指针是一个拥有指针行为的对象，但可以自动管理底层内存。

### 优点：
智能指针在防止内存泄漏方面非常有用，并且是编写异常安全（exception-safe）的代码的基础。它们也在形式上标出了“我持有动态分配的内存”。

### 缺点：
我们倾向于对象只有唯一且固定持有者的设计。允许共享和转移所有权的智能指针，是小心设计所有权语义的一个诱人替代，这会引起代码混乱，甚至是内存泄漏bug。智能指针语义（特别是`auto_ptr`）可能是含糊、另人困惑的。异常安全的好处不是决定性的，因为我们不允许使用异常。

### 结论：
- `unique_ptr` 见[下文](#unique_ptr)。
- `scoped_ptr` 如果不是为了兼容C++03以前的C++版本，应该使用`unique_ptr`。
- `auto_ptr` 所有权转移语义容易造成混乱，引发bug。尽可能使用`unique_ptr`代替。
- `shared_ptr` 管理常量是安全的（如`share_ptr<cont T>`）。非常量的引用计数指针偶尔是好的设计，但是尽可能以唯一所有权持有者为原则重写代码。

## cpplint
使用cpplint.py检查风格错误。

cpplink.py是一个读取源代码并能指出许多风格错误的工具。它并不完美，有时会漏报或误报，但是依然是个有价值的工具。误报可以行尾加`// NOLINT`注释来忽略。

一些项目会指导你使用该项目的工具运行cpplint.py。如果你的项目没有，可以单独[下载](http://google-styleguide.googlecode.com/svn/trunk/cpplint/cpplint.py)。

# 其它C++特性
## 引用参数
所有以引用方式传递的参数都要是`const`的。

### 定义：
在C语言中，如果一个函数要修改一个变量，这个参数就必须是一个指针，如`int foo(int *pval)`。在C++中，有了新的选择就是可以声明一个引用参数：`int foo(int &val)`。

### 优点：
把参数定义成引用参数可以避免像`(*pval)++`这样丑陋的代码。对于像拷贝构造函数这样应用也是必须的。有一点要说清楚，引用不像指针，不能有空引用。

### 缺点：
引用容易引起混乱，因为它有值的语法但语义却是指针。

### 结论：
函数的参数列表中，所有的引用参数都必须是`const`的：
```C++
void Foo(const string &in, string *out);
```

事实上在Google的代码这是一个硬性规定：输入参数是值或`const`引用，而输出参数是指针。输入参数可以是`const`指针，但是非`const`的引用是决不允许的，除非有约定明确要求，比如`swap()`。

然而，确实有时候用`const T*`比`const T&`更合理。如：
- 你想传递一个空指针
- 函数把一个指针或引用保存到输入

记住，大多数情况下输入参数都必须声明成类似`const T&`这样。使用`const T*`是告诉看代码的人这个输入参数被特别对待了。所以一旦你选择使用`const T*`而非`const T&`，一定要有具体的理由，否则就会误导读者去查找一个不存在的解释。

## 函数重载
使用重载函数（包括构造函数）时，一定要确保看代码的人一看到调用就能知道发生了什么，而不用先去查找哪一个重载函数被调用了。

### 定义：
你可以写一个以`const string&`为参数的函数，然后再写一个以`const char *`为指针的。
```C++
class MyClass {
 public:
  void Analyze(const string &text);
  void Analyze(const char *text, size_t textlen);
};
```

### 优点：
通过参数不同的同名函数，重载可以使代码更直观。模板化代码要求重载，这也方便了代码使用者。

### 缺点：
如果一个函数只是以参数不同重载，读者可能需要了解C++复杂的匹配规则来确定将要发生什么。同样，如果继承时一个派生类只重载了函数的一些变体，会使许多人找不着北的。

### 结论：
当你要重载一个函数时，考虑一下让函数含有一些参数信息是不是更好，如，用`AppendString()`，`AppendInt()`代替重载`Append()`。

## 缺省参数
除了下面介绍的有限的几种情况，我们不允许缺省参数的函数。如果合适，就用函数重载来模拟。

### 优点：
你的函数经常会用到默认值，但你偶尔会想要重载这些默认值。使用缺省参数可以轻松搞定，又不必为了这种少数例外定义多个函数。相对于重载函数，缺省参数语法更干净，样板代码更少，可以更清楚地区分‘必须的’和‘可选的’参数。

### 缺点：
有缺省参数的函数指针容易引起混乱，因为函数签名经常和调用签名不匹配。给一个已存在的函数添加一个缺省参数会改变它的类型，对使用其地址的代码来说这可能会有问题。添加一个函数重载就没有这些问题。另外，缺省参数可能使代码变笨重，因为它们在每个调用处都复制一份--与重载函数不同，“默认值”只出现在函数定义处。

### 结论：
尽管上面的缺点并不繁重，但是仍然比相对函数重载的那点好处要大。所以除了下面的情况外，我们要求所有的参数都必须明确指定。

一个特例是当这个函数是一个.cc文件中的静态函数（或在一个匿名命名空间中）时。这时没有上面的缺点，因为函数的使用被本地化了。

另一个特例是缺省参数用以模拟可变参数列表。
```C++
// 使用缺省的空AlphaNum参数，最多可以支持4个参数
string StrCat(const AlphaNum &a,
              const AlphaNum &b = gEmptyAlphaNum,
              const AlphaNum &c = gEmptyAlphaNum,
              const AlphaNum &d = gEmptyAlphaNum);
```

## 变长数组和alloca()
我们不允许使用可变长度数组和`alloca()`。

### 优点：
可变长度数组有自然的语法。可变长度数组和`alloca()`都非常高效。

### 缺点：
可变长度数组和alloca都不属于标准C++。更重要的是，它们根据数据大小分配栈空间，这可能引发难以发觉的内存越界复写bug：“代码在我的机器上没问题，可是在产品中却会莫名其妙地挂掉”。

### 结论：
要使用安全的内存分配器，如`scoped_ptr`/`scope_array`。

## 友元
我们允许合理使用友元类和函数。

友元通常应该定义在同一个文件中，这样读者就不用为了查看这个私有成员的用法而查找另一个文件。友元的一个常用用法是：将`FooBuilder`类定义成`Foo`类的友元来正确构造`Foo`类的内部状态，又不用将内部状态暴露给外面。有时将单元测试类定义成被测试的类的友元很有用。

友元扩展而非破坏了类封装的边界。在一些情况下，如果你只是想在另一个类中访问一个类，友元比使用公有成员更好。当然，大多数类应该通过公有成员来与其它类交互。

## 异常

## unique_ptr
## 函数重载
# 命名
## 函数命名
## 变量命名

# 注释

# 格式

# 规则特例
### Windows代码

# 结束语
